---
title: My Programming Journey
date: 2023-09-27 12:00:00 -0600
categories: [programming,software]
tags: [programming,hardware,software,rust,python]
---

From the earliest days of my childhood, I've been captivated by the art of building and crafting. Whether it was constructing intricate structures with small wooden blocks in kindergarten or tackling complex engineering problems at university, I've always been drawn to the challenge of creating something more than just the sum of its parts.

My passion lies in seeking elegant solutions that require a deep understanding of the underlying principles, rather than settling for quick fixes that merely address the surface issue. I thrive on the puzzle of crafting general solutions that transcend specific values, seeing the bigger picture in every problem I encounter.

Each step of my journey in programming has further fueled my fascination with turning abstract ideas into concrete realities. My focus lies in systems programming and achieving high-performance results. I firmly believe that any remarkable achievement, be it high-performance code or any other ambitious endeavor, must have a solid foundation to not just survive but thrive in the wild.

Throughout my experiences in programming and engineering, I've gained invaluable insights that I'm eager to share in this blog. I hope to provide you with not only useful knowledge but also an entertaining journey into the world of programming.

Programming is a world of trade-offs, where each language has its unique strengths and weaknesses. Learning different languages exposes you to diverse problem-solving approaches. In a nutshell, we can simplify the spectrum: C prioritizes speed, Python emphasizes productivity, and Rust balances safety and speed, albeit with some initial productivity trade-offs. We'll delve deeper into these distinctions in future posts.

Join me on this adventure as I explore the programming languages that have shaped my perspective and provide context for my viewpoints. Together, we'll uncover the beauty and complexity of the programming world, one line of code at a time.

## [LOGO](https://en.wikipedia.org/wiki/Logo_(programming_language))

![LOGO](https://upload.wikimedia.org/wikipedia/commons/thumb/0/09/KochTurtleAnim.gif/300px-KochTurtleAnim.gif)

When I was just 11 years old, my world changed when my mother enrolled me in a programming course. Little did I know that this adventure would introduce me to the magical world of LOGO. It was a week filled with awe-inspiring moments, as I discovered the joy of programming and the art of abstraction.

In that small classroom, I encountered a peculiar friend – a little turtle. This turtle was no ordinary creature; it was a virtual companion that followed instructions and drew lines on the screen. The concept was simple: I could command the turtle with instructions like "right 50, up 50, left 50, down 50," and watch in amazement as it created a perfect square.

But the real enchantment lay in the abstract thinking it required. I had to visualize in my mind what would happen on the screen as the little turtle executed each command. It was like orchestrating a symphony of movement and shapes, all within the confines of my imagination.

I couldn't stop at squares, of course. I dreamt bigger, attempting to draw more complex figures like a castle. However, that's when I faced my first programming challenge – debugging. It was a formidable opponent, but with every error and correction, I learned valuable lessons in patience and problem-solving.

That week, LOGO became the doorway to a universe where creativity and logic intertwined. It ignited a spark that has since fueled my passion for programming. The lessons I learned with that little turtle still resonate with me today, reminding me that even the most complex challenges can be conquered with imagination and determination.

## [Basic](https://en.wikipedia.org/wiki/BASIC)

![basic](https://upload.wikimedia.org/wikipedia/commons/thumb/7/7b/AtariBASIC.png/300px-AtariBASIC.png)

In high school, my journey into programming began. I vividly remember creating mathematical function graphs using basic programming and Mathematica. It was an enthralling introduction to the world of programming, blending logic and creativity.

One of my early challenges was debugging a typo: I'd mistakenly typed a 1 instead of an l for a variable name. The compiler protested an undeclared variable just a line above.

This experience taught me a crucial lesson: attention to detail is paramount. A minor typo can turn a program masterpiece into a puzzle. Yet, it was through debugging that I discovered the thrill of problem-solving and the joy of overcoming challenges.

High school ignited a passion for programming at the intersection of mathematics and code. It's where ideas become elegant solutions, precision is vital, and creativity knows no bounds.


## [C](https://en.wikipedia.org/wiki/C_(programming_language))
![C](https://upload.wikimedia.org/wikipedia/commons/thumb/0/0e/The_C_Programming_Language%2C_First_Edition_Cover.svg/171px-The_C_Programming_Language%2C_First_Edition_Cover.svg.png)

C, the second programming language I encountered during high school, truly captured my heart when I delved into it more seriously during my university's "Intro to Computation" course. Those were the days when I spent my entire summer vacations immersing myself in its intricacies, playing with the compiler, creating mesmerizing drawings, and uncovering its hidden library gems.

C has remained as dependable as ever, an enduring love affair for me. I firmly believe it's the ultimate high-level language for unraveling the inner workings of computers. Its simplicity in syntax and efficient libraries make it a perfect companion for anyone eager to fathom the depths of computing. However, there's a catch – its productivity for real-world tasks can be a bit costly. It's a language best suited for low level, high-performance applications, a testament to its close to metal nature.

Enter C++, the next generation. Today, it's a reigning star, especially for complex systems requiring low-level access and impeccable resource management. C++ boasts powerful libraries, offering an advantage over its predecessor, but it too carries the weight of memory safety concerns.

## [Perl](https://en.wikipedia.org/wiki/Python_(programming_language))

![Perl](https://upload.wikimedia.org/wikipedia/en/0/00/Perl-camel-small.png)

My introduction to Perl at university, within an open-source course, was a revelation. It excelled in parsing text, executing file tests, and crafting nimble scripts. Its intuitive power left a lasting impression.

However, as I ventured into the professional realm, Perl's limitations became apparent for substantial projects. Its reputation as a "write-only" language became clear. While Perl has enabled incredible achievements and remains in legacy code for many enterprise software, contemporary projects now offer better starting options.

## [Python](https://en.wikipedia.org/wiki/Python_(programming_language))

![python](https://upload.wikimedia.org/wikipedia/commons/c/c3/Python-logo-notext.svg)

Python's allure lies in its elegant simplicity and clean code. The mandatory indentation, a novel concept for its time, enhances readability and enforces a unique syntax.

While Python has stood the test of time, boasting both simplicity for newcomers and power for experts, its Achilles' heel has traditionally been performance. However, recent Python versions, such as 3.11, have significantly improved in this aspect. For resource-intensive tasks, integrating other languages like C/C++ or Rust for heavy lifting within a package remains a viable option.

## [Rust: A Breath of Fresh Air in the World of Memory Errors](https://www.rust-lang.org)

![Rust Logo](https://upload.wikimedia.org/wikipedia/commons/d/d5/Rust_programming_language_black_logo.svg)

In the life of a software engineer, grappling with memory errors like null pointers, memory leaks, and out-of-bounds array writes is a common and often stressful ordeal. The pressure to meet deadlines, coupled with the challenge of deciphering poorly documented code and unexpected behaviors, paints a familiar picture.

Enter Rust, a language that promises to alleviate these memory woes by design. While it might be a tad overstated to claim that Rust completely eradicates memory problems, it does shift the battle from runtime to compile time. This means understanding and addressing compiler warnings becomes the game, and once the code compiles, you can breathe easy.

Rust's ability to catch potential issues during compilation is truly remarkable, offering a refreshing solution to the age-old problem of memory errors.


## Rust: Shaping New Patterns and Unveiling Unique Strengths

When you step into the realm of Rust, you're not just adopting a new programming language; you're embracing a fresh mindset. While you could use familiar constructs like loops, Rust's spirit beckons you towards a different path — one where iterators take center stage. It's a shift that transforms how your brain processes tasks and shapes your workflow.

Rust, often hailed as the trifecta of safety, speed, and concurrency, stands out as an exceptionally efficient language. Its prowess hasn't gone unnoticed, with the Linux kernel welcoming it as the second language for use this year, a testament to Rust's growing prominence.

My journey with Rust began in 2020, but it's in 2023 that I've delved more earnestly into its intricacies. I'm excited to explore this language further, delve into cool projects, and share our discoveries and insights along the way.

For those curious about why Rust is garnering attention for modern high optimization challenges, I highly recommend the article ["Rust is the Best Language For Data Infra"](https://www.arroyo.dev/blog/rust-for-data-infra). It's a compelling read that dissects Rust's unique strengths in detail, shedding light on what makes it such a standout choice in the world of programming.

## [Ikigai: Where Passion, Purpose, and Paycheck Meet](https://medium.com/@marenkate/ikigai-and-the-four-ps-how-to-get-paid-enjoy-your-work-solve-problems-and-find-purpose-8c9dc615648f)

I would like to explain the reason for the reference of the term ikigai. In simple terms, Ikigai is the sweet spot where three things come together:

1) Passion: What you love and enjoy doing.
2) Purpose: What the world needs or values.
3) Paycheck: What you can earn a living from.

For us, as programmers, it means finding a way to make a living doing something we're passionate about—programming. It's about finding that perfect balance where your work aligns with your interests, benefits the world, and provides for your needs.

![ikigai](https://www.researchgate.net/profile/Daphna-Arbell-Kehila-2/publication/331982903/figure/fig3/AS:740356199038990@1553526081990/IKIGAI-A-Japanese-concept-meaning-A-Reason-for-Living-This-figure.jpg){: width="700" height="400" }

credit: [researchgate.net](https://www.researchgate.net/figure/IKIGAI-A-Japanese-concept-meaning-A-Reason-for-Living-This-figure_fig3_331982903)

